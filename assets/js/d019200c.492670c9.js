"use strict";(self.webpackChunksailpoint_developer_portal=self.webpackChunksailpoint_developer_portal||[]).push([["766721"],{540488(e,t,r){r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});var n=r(109793),s=r(474848),i=r(28453);let a={id:"date-compare",title:"Date Compare",pagination_label:"Date Compare",sidebar_label:"Date Compare",sidebar_class_name:"dateCompare",keywords:["transforms","operations","date","compare"],description:"Compare two dates and return a calculated value.",slug:"/extensibility/transforms/operations/date-compare",tags:["Transforms","Transform Operations"]},o,d={},l=[{value:"Overview",id:"overview",level:2},{value:"Transform structure",id:"transform-structure",level:2},{value:"Top-level properties (required)",id:"top-level-properties-required",level:2},{value:"Attributes",id:"attributes",level:2},{value:"<code>attributes</code> (required)",id:"attributes-required",level:3},{value:"Required",id:"required",level:4},{value:"Examples",id:"examples",level:2}];function c(e){let t={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:'Use the date compare transform to compare two dates and, depending on the comparison result, return one value if one date is after the other or return a different value if it is before the other. A common use case is to calculate lifecycle states (e.g., the user is "active" if the current date is greater than or equal to the user\'s hire date, etc.).'}),"\n",(0,s.jsx)(t.admonition,{title:"Other Considerations",type:"note",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:'In addition to explicit date values, the transform recognizes the "now" keyword that always evaluates to the exact date and time when the transform is evaluating.'}),"\n",(0,s.jsxs)(t.li,{children:["All dates ",(0,s.jsx)(t.strong,{children:"must"})," be in ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/ISO_8601",children:"ISO8601 format"})," in order for the date compare transform to evaluate properly."]}),"\n"]})}),"\n",(0,s.jsx)(t.h2,{id:"transform-structure",children:"Transform structure"}),"\n",(0,s.jsxs)(t.p,{children:["The date compare transform takes as an input the two dates to compare, denoted as ",(0,s.jsx)(t.code,{children:"firstDate"})," and ",(0,s.jsx)(t.code,{children:"secondDate"}),". The transform also requires an ",(0,s.jsx)(t.code,{children:"operator"})," designation so it knows which condition to evaluate for. Lastly, the transform requires both a ",(0,s.jsx)(t.code,{children:"positiveCondition"})," and a ",(0,s.jsx)(t.code,{children:"negativeCondition"})," -- the former returns if the comparison evaluates to ",(0,s.jsx)(t.code,{children:"true"}),"; the latter returns if the comparison evaluates to ",(0,s.jsx)(t.code,{children:"false"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "attributes": {\n    "firstDate": {\n      "attributes": {\n        "sourceName": "HR Source",\n        "attributeName": "termination_date"\n      },\n      "type": "accountAttribute"\n    },\n    "secondDate": "now",\n    "operator": "gt",\n    "positiveCondition": "active",\n    "negativeCondition": "terminated"\n  },\n  "type": "dateCompare",\n  "name": "Date Compare Transform"\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"top-level-properties-required",children:"Top-level properties (required)"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"type"})," ",(0,s.jsx)(t.code,{children:"string"})," ",(0,s.jsx)(t.em,{children:"(required)"}),(0,s.jsx)(t.br,{}),"\n","Must be set to ",(0,s.jsx)(t.code,{children:"dateCompare"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"name"})," ",(0,s.jsx)(t.code,{children:"string"})," ",(0,s.jsx)(t.em,{children:"(required)"}),(0,s.jsx)(t.br,{}),"\n","The name of the transform as it will appear in the UI's dropdown menus."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"requiresPeriodicRefresh"})," ",(0,s.jsx)(t.code,{children:"boolean"})," ",(0,s.jsx)(t.em,{children:"(optional)"}),(0,s.jsx)(t.br,{}),"\n","Whether the transform logic should be reevaluated every evening as part of the identity refresh process. Default is ",(0,s.jsx)(t.code,{children:"false"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"attributes",children:"Attributes"}),"\n",(0,s.jsx)(t.p,{children:"The date compare transform uses the following structure:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "type": "dateCompare",\n  "name": "Transform Name",\n  "attributes": {\n    "firstDate": "2024-01-01T00:00:00Z",\n    "secondDate": "now",\n    "operator": "gt",\n    "positiveCondition": "true",\n    "negativeCondition": "false"\n  }\n}\n'})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsxs)(t.h3,{id:"attributes-required",children:[(0,s.jsx)(t.code,{children:"attributes"})," (required)"]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"attributes"})," object contains the date comparison configuration."]}),"\n",(0,s.jsx)(t.h4,{id:"required",children:"Required"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"firstDate"})," ",(0,s.jsx)(t.code,{children:"string"})," | ",(0,s.jsx)(t.code,{children:"object"})," ",(0,s.jsx)(t.em,{children:"(required)"}),(0,s.jsx)(t.br,{}),"\n","The first date to compare (left-hand side of the comparison). Must be in ISO8601 format or the keyword ",(0,s.jsx)(t.code,{children:'"now"'}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"secondDate"})," ",(0,s.jsx)(t.code,{children:"string"})," | ",(0,s.jsx)(t.code,{children:"object"})," ",(0,s.jsx)(t.em,{children:"(required)"}),(0,s.jsx)(t.br,{}),"\n","The second date to compare (right-hand side of the comparison). Must be in ISO8601 format or the keyword ",(0,s.jsx)(t.code,{children:'"now"'}),"."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"operator"})," ",(0,s.jsx)(t.code,{children:"string"})," ",(0,s.jsx)(t.em,{children:"(required)"}),(0,s.jsx)(t.br,{}),"\n","The comparison operator to perform:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"LT"})," - Strictly less than: firstDate ",(0,s.jsx)(t.code,{children:"<"})," secondDate"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"LTE"})," - Less than or equal to: firstDate ",(0,s.jsx)(t.code,{children:"<="})," secondDate"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"GT"})," - Strictly greater than: firstDate ",(0,s.jsx)(t.code,{children:">"})," secondDate"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"GTE"})," - Greater than or equal to: firstDate ",(0,s.jsx)(t.code,{children:">="})," secondDate"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"positiveCondition"})," ",(0,s.jsx)(t.code,{children:"string"})," ",(0,s.jsx)(t.em,{children:"(required)"}),(0,s.jsx)(t.br,{}),"\n","The value to return if the comparison evaluates to true."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"negativeCondition"})," ",(0,s.jsx)(t.code,{children:"string"})," ",(0,s.jsx)(t.em,{children:"(required)"}),(0,s.jsx)(t.br,{}),"\n","The value to return if the comparison evaluates to false."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(t.p,{children:["This transform accomplishes a basic lifecycle state calculation. It compares the user's termination date with his/her HR record. If the current datetime (denoted by ",(0,s.jsx)(t.code,{children:"now"}),') is less than that date, the transform returns "active". If the current datetime is greater than that date, the transform returns "terminated".']}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Transform request body"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "attributes": {\n    "firstDate": {\n      "attributes": {\n        "sourceName": "HR Source",\n        "attributeName": "termination_date"\n      },\n      "type": "accountAttribute"\n    },\n    "secondDate": "now",\n    "operator": "gt",\n    "positiveCondition": "active",\n    "negativeCondition": "terminated"\n  },\n  "type": "dateCompare",\n  "name": "Date Compare Transform"\n}\n'})}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)("p",{children:"\xa0"}),"\n",(0,s.jsx)(t.p,{children:'This transform compares the user\'s hire date to a fixed date in the past. If the user was hired prior to January 1, 1996, the transform returns "legacy". If the user was hired later than January 1, 1996, it returns "regular".'}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Transform request body"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n  "attributes": {\n    "firstDate": {\n      "attributes": {\n        "sourceName": "HR Source",\n        "attributeName": "hire_date"\n      },\n      "type": "accountAttribute"\n    },\n    "secondDate": {\n      "attributes": {\n        "input": "12/31/1995",\n        "inputFormat": "M/d/yyyy",\n        "outputFormat": "ISO8601"\n      },\n      "type": "dateFormat"\n    },\n    "operator": "lte",\n    "positiveCondition": "legacy",\n    "negativeCondition": "regular"\n  },\n  "type": "dateCompare",\n  "name": "Date Compare Transform"\n}\n'})})]})}function h(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453(e,t,r){r.d(t,{R:()=>a,x:()=>o});var n=r(296540);let s={},i=n.createContext(s);function a(e){let t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(i.Provider,{value:t},e.children)}},109793(e){e.exports=JSON.parse('{"id":"extensibility/transforms/operations/date-compare","title":"Date Compare","description":"Compare two dates and return a calculated value.","source":"@site/docs/extensibility/transforms/operations/date-compare.md","sourceDirName":"extensibility/transforms/operations","slug":"/extensibility/transforms/operations/date-compare","permalink":"/docs/extensibility/transforms/operations/date-compare","draft":false,"unlisted":false,"editUrl":"https://github.com/sailpoint-oss/developer.sailpoint.com/edit/main/docs/extensibility/transforms/operations/date-compare.md","tags":[{"inline":true,"label":"Transforms","permalink":"/docs/tags/transforms"},{"inline":true,"label":"Transform Operations","permalink":"/docs/tags/transform-operations"}],"version":"current","lastUpdatedBy":"Tyler Mairose","lastUpdatedAt":1763490547000,"frontMatter":{"id":"date-compare","title":"Date Compare","pagination_label":"Date Compare","sidebar_label":"Date Compare","sidebar_class_name":"dateCompare","keywords":["transforms","operations","date","compare"],"description":"Compare two dates and return a calculated value.","slug":"/extensibility/transforms/operations/date-compare","tags":["Transforms","Transform Operations"]},"sidebar":"openApiSidebar","previous":{"title":"Conditional","permalink":"/docs/extensibility/transforms/operations/conditional"},"next":{"title":"Date Format","permalink":"/docs/extensibility/transforms/operations/date-format"}}')}}]);