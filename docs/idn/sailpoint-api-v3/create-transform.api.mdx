---
id: create-transform
sidebar_label: Create transform
hide_title: true
hide_table_of_contents: true
api: {"tags":["Transforms"],"description":"Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.","operationId":"createTransform","requestBody":{"required":true,"description":"The transform to be created.","content":{"application/json":{"schema":{"type":"object","description":"The representation of an internally- or customer-defined transform.","required":["name","type","attributes"],"properties":{"id":{"type":"string","readOnly":true,"description":"Unique ID of this transform","example":"2cd78adghjkja34jh2b1hkjhasuecd"},"name":{"type":"string","description":"Unique name of this transform","example":"Timestamp To Date"},"type":{"type":"string","description":"The type of transform operation","enum":["accountAttribute","base64Decode","base64Encode","concat","conditional","dateCompare","dateFormat","dateMath","decomposeDiacriticalMarks","e164phone","firstValid","rule","identityAttribute","indexOf","iso3166","lastIndexOf","leftPad","lookup","lower","normalizeNames","randomAlphaNumeric","randomNumeric","reference","replaceAll","replace","rightPad","split","static","substring","trim","upper","usernameGenerator","uuid"],"example":"dateFormat","externalDocs":{"description":"Transform Operations","url":"https://developer.sailpoint.com/docs/transforms/transform_operations/transform_operations.html#transform-operations"}},"attributes":{"description":"Meta-data about the transform. Values in this list are specific to the type of transform to be executed.","oneOf":[{"title":"accountAttribute","type":"object","required":["sourceName","attributeName"],"properties":{"sourceName":{"type":"string","description":"A reference to the source to search for the account","example":"Workday"},"attributeName":{"type":"string","description":"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.","example":"DEPARTMENT"},"accountSortAttribute":{"type":"string","description":"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries","example":"created"},"accountSortDescending":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)","example":false},"accountReturnFirstLink":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false","example":false},"accountFilter":{"type":"string","description":"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements","example":"!(nativeIdentity.startsWith(\"*DELETED*\"))"},"accountPropertyFilter":{"type":"string","description":"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory.","example":"(groups.containsAll({'Admin'}) || location == 'Austin')"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"base64Decode","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"base64Encode","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"concat","type":"object","required":["values"],"properties":{"values":{"type":"array","items":{"type":"object"},"description":"An array of items to join together","example":["John"," ","Smith"]},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"conditional","type":"object","required":["expression","positiveCondition","negativeCondition"],"properties":{"expression":{"type":"string","description":"A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms. \n\nThe `eq` operator is the only valid comparison","example":"ValueA eq ValueB"},"positiveCondition":{"type":"string","description":"The output of the transform if the expression evalutes to true","example":"true"},"negativeCondition":{"type":"string","description":"The output of the transform if the expression evalutes to false","example":"false"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateCompare","type":"object","required":["firstDate","secondDate","operator","positiveCondition","negativeCondition"],"properties":{"firstDate":{"description":"This is the first date to consider (The date that would be on the left hand side of the comparison operation).","oneOf":[{"title":"accountAttribute","type":"object","required":["sourceName","attributeName"],"properties":{"sourceName":{"type":"string","description":"A reference to the source to search for the account","example":"Workday"},"attributeName":{"type":"string","description":"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.","example":"DEPARTMENT"},"accountSortAttribute":{"type":"string","description":"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries","example":"created"},"accountSortDescending":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)","example":false},"accountReturnFirstLink":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false","example":false},"accountFilter":{"type":"string","description":"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements","example":"!(nativeIdentity.startsWith(\"*DELETED*\"))"},"accountPropertyFilter":{"type":"string","description":"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory.","example":"(groups.containsAll({'Admin'}) || location == 'Austin')"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateFormat","type":"object","properties":{"inputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"outputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}}]},"secondDate":{"description":"This is the second date to consider (The date that would be on the right hand side of the comparison operation).","oneOf":[{"title":"accountAttribute","type":"object","required":["sourceName","attributeName"],"properties":{"sourceName":{"type":"string","description":"A reference to the source to search for the account","example":"Workday"},"attributeName":{"type":"string","description":"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.","example":"DEPARTMENT"},"accountSortAttribute":{"type":"string","description":"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries","example":"created"},"accountSortDescending":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)","example":false},"accountReturnFirstLink":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false","example":false},"accountFilter":{"type":"string","description":"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements","example":"!(nativeIdentity.startsWith(\"*DELETED*\"))"},"accountPropertyFilter":{"type":"string","description":"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory.","example":"(groups.containsAll({'Admin'}) || location == 'Austin')"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateFormat","type":"object","properties":{"inputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"outputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}}]},"operator":{"type":"string","description":"This is the comparison to perform.\n| Operation | Description |\n| --------- | ------- |\n| LT        | Strictly less than: firstDate < secondDate |\n| LTE       | Less than or equal to: firstDate <= secondDate |\n| GT        | Strictly greater than: firstDate > secondDate |\n| GTE       | Greater than or equal to: firstDate >= secondDate |\n","enum":["LT","LTE","GT","GTE"],"example":"LT"},"positiveCondition":{"type":"string","description":"The output of the transform if the expression evalutes to true","example":"true"},"negativeCondition":{"type":"string","description":"The output of the transform if the expression evalutes to false","example":false},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateFormat","type":"object","properties":{"inputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"outputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateMath","type":"object","required":["expression"],"properties":{"expression":{"type":"string","description":"A string value of the date and time components to operation on, along with the math operations to execute.\n","externalDocs":{"description":"Date Math Expressions","url":"https://developer.sailpoint.com/docs/transforms/transform_operations/operations/date_math.html#transform-structure"},"example":"now+1w"},"roundUp":{"type":"boolean","description":"A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression. \n\n\nIf not provided, the transform will default to `false`\n\n\n`true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)\n\n\n`false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated)\n","example":false},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"decomposeDiacriticalMarks","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"e164phone","type":"object","properties":{"defaultRegion":{"type":"string","description":"This is an optional attribute that can be used to define the region of the phone number to format into.\n\n\nIf defaultRegion is not provided, it will take US as the default country.\n\n\nThe format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)\n","example":"US"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"firstValid","type":"object","required":["values"],"properties":{"values":{"type":"array","items":{"type":"object"},"description":"An array of attributes to evaluate for existence.","example":[{"attributes":{"sourceName":"Active Directory","attributeName":"sAMAccountName"},"type":"accountAttribute"},{"attributes":{"sourceName":"Okta","attributeName":"login"},"type":"accountAttribute"},{"attributes":{"sourceName":"HR Source","attributeName":"employeeID"},"type":"accountAttribute"}]},"ignoreErrors":{"type":"boolean","description":"a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur.","example":false},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false}}},{"title":"rule","oneOf":[{"type":"object","required":["name"],"properties":{"name":{"type":"string","description":"This is the name of the Generic rule that needs to be invoked by the transform","example":"Generic Calculation Rule"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false}}},{"type":"object","required":["name","operation","includeNumbers","includeSpecialChars","length"],"properties":{"name":{"type":"string","description":"This must always be set to \"Cloud Services Deployment Utility\"","example":"Cloud Services Deployment Utility"},"operation":{"type":"string","description":"The operation to perform `generateRandomString`","example":"generateRandomString"},"includeNumbers":{"type":"boolean","description":"This must be either \"true\" or \"false\" to indicate whether the generator logic should include numbers","example":true},"includeSpecialChars":{"type":"boolean","description":"This must be either \"true\" or \"false\" to indicate whether the generator logic should include special characters","example":true},"length":{"type":"string","description":"This specifies how long the randomly generated string needs to be\n\n\n>NOTE Due to identity attribute data constraints, the maximum allowable value is 450 characters\n","example":"10"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false}}},{"type":"object","required":["name","operation","uid"],"properties":{"name":{"type":"string","description":"This must always be set to \"Cloud Services Deployment Utility\"","example":"Cloud Services Deployment Utility"},"operation":{"type":"string","description":"The operation to perform `getReferenceIdentityAttribute`","example":"getReferenceIdentityAttribute"},"uid":{"type":"string","description":"This is the SailPoint User Name (uid) value of the identity whose attribute is desired\n\nAs a convenience feature, you can use the `manager` keyword to dynamically look up the user's manager and then get that manager's identity attribute.\n","example":"2c91808570313110017040b06f344ec9"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false}}}]},{"title":"identityAttribute","type":"object","required":["name"],"properties":{"name":{"type":"string","description":"The system (camel-cased) name of the identity attribute to bring in","example":"email"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"indexOf","type":"object","required":["substring"],"properties":{"substring":{"type":"string","description":"A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring.","example":"admin_"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"iso3166","type":"object","properties":{"format":{"type":"string","description":"An optional value to denote which ISO 3166 format to return. Valid values are:\n\n\n`alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied\n\n\n`alpha3` - Three-character country code (e.g., \"USA\")\n\n\n`numeric` - The numeric country code (e.g., \"840\")\n","example":"alpha2"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"leftPad","type":"object","required":["length"],"properties":{"length":{"type":"string","description":"An integer value for the desired length of the final output string","example":"4"},"padding":{"type":"string","description":"A string value representing the character that the incoming data should be padded with to get to the desired length\n\n\nIf not provided, the transform will default to a single space (\" \") character for padding\n","example":"0"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"lookup","type":"object","required":["table"],"properties":{"table":{"type":"object","additionalProperties":true,"description":"This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched\n\n\n>**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return \"Unknown Region\" for the attribute that is mapped to this transform.\n","example":{"USA":"Americas","FRA":"EMEA","AUS":"APAC","default":"Unknown Region"}},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"lower","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"nameNormalizer","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"randomAlphaNumeric","type":"object","properties":{"length":{"type":"string","description":"This is an integer value specifying the size/number of characters the random string must contain\n\n\n* This value must be a positive number and cannot be blank\n\n\n* If no length is provided, the transform will default to a value of `32`\n\n\n* Due to identity attribute data constraints, the maximum allowable value is `450` characters\n","example":"10"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"randomNumeric","type":"object","properties":{"length":{"type":"string","description":"This is an integer value specifying the size/number of characters the random string must contain\n\n\n* This value must be a positive number and cannot be blank\n\n\n* If no length is provided, the transform will default to a value of `32`\n\n\n* Due to identity attribute data constraints, the maximum allowable value is `450` characters\n","example":"10"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"reference","type":"object","required":["id"],"properties":{"id":{"type":"string","description":"This ID specifies the name of the pre-existing transform which you want to use within your current transform","example":"Existing Transform"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"replaceAll","type":"object","required":["table"],"properties":{"table":{"type":"object","additionalProperties":true,"description":"An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.","example":{"-":" ","\"":"'","Ã±":"n"}},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"replace","type":"object","required":["regex","replacement"],"properties":{"regex":{"type":"string","description":"This can be a string or a regex pattern in which you want to replace.","example":"[^a-zA-Z]","externalDocs":{"description":"Regex Builder","url":"https://regex101.com/"}},"replacement":{"type":"string","description":"This is the replacement string that should be substituded wherever the string or pattern is found.","example":" "},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"rightPad","type":"object","required":["length"],"properties":{"length":{"type":"string","description":"An integer value for the desired length of the final output string","example":"4"},"padding":{"type":"string","description":"A string value representing the character that the incoming data should be padded with to get to the desired length\n\n\nIf not provided, the transform will default to a single space (\" \") character for padding\n","example":"0"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"split","type":"object","required":["delimiter","index"],"properties":{"delimiter":{"type":"string","description":"This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data","example":","},"index":{"type":"string","description":"An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc.","example":"5"},"throws":{"type":"boolean","description":"A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)\n\n\n`true` - The transform should return \"IndexOutOfBoundsException\"\n\n\n`false` - The transform should return null\n\n\nIf not provided, the transform will default to false and return a null\n","example":true},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"static","type":"object","required":["values"],"properties":{"values":{"type":"string","description":"This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language.","example":"string$variable","externalDocs":{"description":"Static Transform Documentation","url":"https://developer.sailpoint.com/docs/transforms/transform_operations/operations/static.html"}},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false}}},{"title":"substring","type":"object","required":["begin"],"properties":{"begin":{"type":"integer","description":"The index of the first character to include in the returned substring.\n\n\nIf `begin` is set to -1, the transform will begin at character 0 of the input data\n","example":1,"format":"int32"},"beginOffset":{"type":"integer","description":"This integer value is the number of characters to add to the begin attribute when returning a substring. \n\nThis attribute is only used if begin is not -1.\n","example":3,"format":"int32"},"end":{"type":"integer","description":"The index of the first character to exclude from the returned substring.\n\nIf end is -1 or not provided at all, the substring transform will return everything up to the end of the input string.\n","example":6,"format":"int32"},"endOffset":{"type":"integer","description":"This integer value is the number of characters to add to the end attribute when returning a substring. \n\nThis attribute is only used if end is provided and is not -1.\n","example":1,"format":"int32"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"trim","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"upper","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"uuid","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false}}}]},"internal":{"type":"boolean","readOnly":true,"description":"Indicates whether this is an internal SailPoint-created transform or a customer-created transform","example":false}}},"example":{"name":"Timestamp To Date","type":"dateFormat","attributes":{"inputFormat":"MMM dd yyyy, HH:mm:ss.SSS","outputFormat":"yyyy/dd/MM"}}}}},"responses":{"201":{"description":"Indicates the transform was successfully created and returns its representation.","content":{"application/json":{"schema":{"type":"object","description":"The representation of an internally- or customer-defined transform.","required":["name","type","attributes"],"properties":{"id":{"type":"string","readOnly":true,"description":"Unique ID of this transform","example":"2cd78adghjkja34jh2b1hkjhasuecd"},"name":{"type":"string","description":"Unique name of this transform","example":"Timestamp To Date"},"type":{"type":"string","description":"The type of transform operation","enum":["accountAttribute","base64Decode","base64Encode","concat","conditional","dateCompare","dateFormat","dateMath","decomposeDiacriticalMarks","e164phone","firstValid","rule","identityAttribute","indexOf","iso3166","lastIndexOf","leftPad","lookup","lower","normalizeNames","randomAlphaNumeric","randomNumeric","reference","replaceAll","replace","rightPad","split","static","substring","trim","upper","usernameGenerator","uuid"],"example":"dateFormat","externalDocs":{"description":"Transform Operations","url":"https://developer.sailpoint.com/docs/transforms/transform_operations/transform_operations.html#transform-operations"}},"attributes":{"description":"Meta-data about the transform. Values in this list are specific to the type of transform to be executed.","oneOf":[{"title":"accountAttribute","type":"object","required":["sourceName","attributeName"],"properties":{"sourceName":{"type":"string","description":"A reference to the source to search for the account","example":"Workday"},"attributeName":{"type":"string","description":"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.","example":"DEPARTMENT"},"accountSortAttribute":{"type":"string","description":"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries","example":"created"},"accountSortDescending":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)","example":false},"accountReturnFirstLink":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false","example":false},"accountFilter":{"type":"string","description":"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements","example":"!(nativeIdentity.startsWith(\"*DELETED*\"))"},"accountPropertyFilter":{"type":"string","description":"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory.","example":"(groups.containsAll({'Admin'}) || location == 'Austin')"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"base64Decode","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"base64Encode","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"concat","type":"object","required":["values"],"properties":{"values":{"type":"array","items":{"type":"object"},"description":"An array of items to join together","example":["John"," ","Smith"]},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"conditional","type":"object","required":["expression","positiveCondition","negativeCondition"],"properties":{"expression":{"type":"string","description":"A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms. \n\nThe `eq` operator is the only valid comparison","example":"ValueA eq ValueB"},"positiveCondition":{"type":"string","description":"The output of the transform if the expression evalutes to true","example":"true"},"negativeCondition":{"type":"string","description":"The output of the transform if the expression evalutes to false","example":"false"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateCompare","type":"object","required":["firstDate","secondDate","operator","positiveCondition","negativeCondition"],"properties":{"firstDate":{"description":"This is the first date to consider (The date that would be on the left hand side of the comparison operation).","oneOf":[{"title":"accountAttribute","type":"object","required":["sourceName","attributeName"],"properties":{"sourceName":{"type":"string","description":"A reference to the source to search for the account","example":"Workday"},"attributeName":{"type":"string","description":"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.","example":"DEPARTMENT"},"accountSortAttribute":{"type":"string","description":"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries","example":"created"},"accountSortDescending":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)","example":false},"accountReturnFirstLink":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false","example":false},"accountFilter":{"type":"string","description":"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements","example":"!(nativeIdentity.startsWith(\"*DELETED*\"))"},"accountPropertyFilter":{"type":"string","description":"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory.","example":"(groups.containsAll({'Admin'}) || location == 'Austin')"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateFormat","type":"object","properties":{"inputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"outputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}}]},"secondDate":{"description":"This is the second date to consider (The date that would be on the right hand side of the comparison operation).","oneOf":[{"title":"accountAttribute","type":"object","required":["sourceName","attributeName"],"properties":{"sourceName":{"type":"string","description":"A reference to the source to search for the account","example":"Workday"},"attributeName":{"type":"string","description":"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema.","example":"DEPARTMENT"},"accountSortAttribute":{"type":"string","description":"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries","example":"created"},"accountSortDescending":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)","example":false},"accountReturnFirstLink":{"type":"string","description":"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false","example":false},"accountFilter":{"type":"string","description":"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements","example":"!(nativeIdentity.startsWith(\"*DELETED*\"))"},"accountPropertyFilter":{"type":"string","description":"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory.","example":"(groups.containsAll({'Admin'}) || location == 'Austin')"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateFormat","type":"object","properties":{"inputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"outputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}}]},"operator":{"type":"string","description":"This is the comparison to perform.\n| Operation | Description |\n| --------- | ------- |\n| LT        | Strictly less than: firstDate < secondDate |\n| LTE       | Less than or equal to: firstDate <= secondDate |\n| GT        | Strictly greater than: firstDate > secondDate |\n| GTE       | Greater than or equal to: firstDate >= secondDate |\n","enum":["LT","LTE","GT","GTE"],"example":"LT"},"positiveCondition":{"type":"string","description":"The output of the transform if the expression evalutes to true","example":"true"},"negativeCondition":{"type":"string","description":"The output of the transform if the expression evalutes to false","example":false},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateFormat","type":"object","properties":{"inputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"outputFormat":{"description":"A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.\n\n*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*","oneOf":[{"title":"Named Construct","type":"string","description":"| Construct       | Date Time Pattern | Description |\n| ---------       | ----------------- | ----------- |\n| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          \n| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |\n| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |\n| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |\n| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |\n","enum":["ISO8601","LDAP","PEOPLE_SOFT","EPOCH_TIME_JAVA","EPOCH_TIME_WIN32"],"example":"PEOPLE_SOFT"},{"title":"Java Simple Date Format","type":"string","description":"There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.\n\n>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.\n  (This table is from the SimpleDateFormat page.)\n\n| Date Time Pattern | Result |\n| ----------------- | ------ |\n| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |\n| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |\n| `h:mm a`           | 12:08 PM |\n| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |\n| `K:mm a, z`             | 0:08 PM, PDT |\n| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |\n| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |\n| `yyMMddHHmmssZ`               | 010704120856-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |\n| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |\n| `YYYY-'W'ww-u`                 | 2001-W27-3 |\n","example":"mm/dd/yyyy"}]},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"dateMath","type":"object","required":["expression"],"properties":{"expression":{"type":"string","description":"A string value of the date and time components to operation on, along with the math operations to execute.\n","externalDocs":{"description":"Date Math Expressions","url":"https://developer.sailpoint.com/docs/transforms/transform_operations/operations/date_math.html#transform-structure"},"example":"now+1w"},"roundUp":{"type":"boolean","description":"A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression. \n\n\nIf not provided, the transform will default to `false`\n\n\n`true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)\n\n\n`false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated)\n","example":false},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"decomposeDiacriticalMarks","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"e164phone","type":"object","properties":{"defaultRegion":{"type":"string","description":"This is an optional attribute that can be used to define the region of the phone number to format into.\n\n\nIf defaultRegion is not provided, it will take US as the default country.\n\n\nThe format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)\n","example":"US"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"firstValid","type":"object","required":["values"],"properties":{"values":{"type":"array","items":{"type":"object"},"description":"An array of attributes to evaluate for existence.","example":[{"attributes":{"sourceName":"Active Directory","attributeName":"sAMAccountName"},"type":"accountAttribute"},{"attributes":{"sourceName":"Okta","attributeName":"login"},"type":"accountAttribute"},{"attributes":{"sourceName":"HR Source","attributeName":"employeeID"},"type":"accountAttribute"}]},"ignoreErrors":{"type":"boolean","description":"a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur.","example":false},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false}}},{"title":"rule","oneOf":[{"type":"object","required":["name"],"properties":{"name":{"type":"string","description":"This is the name of the Generic rule that needs to be invoked by the transform","example":"Generic Calculation Rule"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false}}},{"type":"object","required":["name","operation","includeNumbers","includeSpecialChars","length"],"properties":{"name":{"type":"string","description":"This must always be set to \"Cloud Services Deployment Utility\"","example":"Cloud Services Deployment Utility"},"operation":{"type":"string","description":"The operation to perform `generateRandomString`","example":"generateRandomString"},"includeNumbers":{"type":"boolean","description":"This must be either \"true\" or \"false\" to indicate whether the generator logic should include numbers","example":true},"includeSpecialChars":{"type":"boolean","description":"This must be either \"true\" or \"false\" to indicate whether the generator logic should include special characters","example":true},"length":{"type":"string","description":"This specifies how long the randomly generated string needs to be\n\n\n>NOTE Due to identity attribute data constraints, the maximum allowable value is 450 characters\n","example":"10"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false}}},{"type":"object","required":["name","operation","uid"],"properties":{"name":{"type":"string","description":"This must always be set to \"Cloud Services Deployment Utility\"","example":"Cloud Services Deployment Utility"},"operation":{"type":"string","description":"The operation to perform `getReferenceIdentityAttribute`","example":"getReferenceIdentityAttribute"},"uid":{"type":"string","description":"This is the SailPoint User Name (uid) value of the identity whose attribute is desired\n\nAs a convenience feature, you can use the `manager` keyword to dynamically look up the user's manager and then get that manager's identity attribute.\n","example":"2c91808570313110017040b06f344ec9"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false}}}]},{"title":"identityAttribute","type":"object","required":["name"],"properties":{"name":{"type":"string","description":"The system (camel-cased) name of the identity attribute to bring in","example":"email"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"indexOf","type":"object","required":["substring"],"properties":{"substring":{"type":"string","description":"A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring.","example":"admin_"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"iso3166","type":"object","properties":{"format":{"type":"string","description":"An optional value to denote which ISO 3166 format to return. Valid values are:\n\n\n`alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied\n\n\n`alpha3` - Three-character country code (e.g., \"USA\")\n\n\n`numeric` - The numeric country code (e.g., \"840\")\n","example":"alpha2"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"leftPad","type":"object","required":["length"],"properties":{"length":{"type":"string","description":"An integer value for the desired length of the final output string","example":"4"},"padding":{"type":"string","description":"A string value representing the character that the incoming data should be padded with to get to the desired length\n\n\nIf not provided, the transform will default to a single space (\" \") character for padding\n","example":"0"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"lookup","type":"object","required":["table"],"properties":{"table":{"type":"object","additionalProperties":true,"description":"This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched\n\n\n>**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return \"Unknown Region\" for the attribute that is mapped to this transform.\n","example":{"USA":"Americas","FRA":"EMEA","AUS":"APAC","default":"Unknown Region"}},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"lower","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"nameNormalizer","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"randomAlphaNumeric","type":"object","properties":{"length":{"type":"string","description":"This is an integer value specifying the size/number of characters the random string must contain\n\n\n* This value must be a positive number and cannot be blank\n\n\n* If no length is provided, the transform will default to a value of `32`\n\n\n* Due to identity attribute data constraints, the maximum allowable value is `450` characters\n","example":"10"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"randomNumeric","type":"object","properties":{"length":{"type":"string","description":"This is an integer value specifying the size/number of characters the random string must contain\n\n\n* This value must be a positive number and cannot be blank\n\n\n* If no length is provided, the transform will default to a value of `32`\n\n\n* Due to identity attribute data constraints, the maximum allowable value is `450` characters\n","example":"10"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"reference","type":"object","required":["id"],"properties":{"id":{"type":"string","description":"This ID specifies the name of the pre-existing transform which you want to use within your current transform","example":"Existing Transform"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"replaceAll","type":"object","required":["table"],"properties":{"table":{"type":"object","additionalProperties":true,"description":"An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.","example":{"-":" ","\"":"'","Ã±":"n"}},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"replace","type":"object","required":["regex","replacement"],"properties":{"regex":{"type":"string","description":"This can be a string or a regex pattern in which you want to replace.","example":"[^a-zA-Z]","externalDocs":{"description":"Regex Builder","url":"https://regex101.com/"}},"replacement":{"type":"string","description":"This is the replacement string that should be substituded wherever the string or pattern is found.","example":" "},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"rightPad","type":"object","required":["length"],"properties":{"length":{"type":"string","description":"An integer value for the desired length of the final output string","example":"4"},"padding":{"type":"string","description":"A string value representing the character that the incoming data should be padded with to get to the desired length\n\n\nIf not provided, the transform will default to a single space (\" \") character for padding\n","example":"0"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"split","type":"object","required":["delimiter","index"],"properties":{"delimiter":{"type":"string","description":"This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data","example":","},"index":{"type":"string","description":"An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc.","example":"5"},"throws":{"type":"boolean","description":"A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)\n\n\n`true` - The transform should return \"IndexOutOfBoundsException\"\n\n\n`false` - The transform should return null\n\n\nIf not provided, the transform will default to false and return a null\n","example":true},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"static","type":"object","required":["values"],"properties":{"values":{"type":"string","description":"This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language.","example":"string$variable","externalDocs":{"description":"Static Transform Documentation","url":"https://developer.sailpoint.com/docs/transforms/transform_operations/operations/static.html"}},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false}}},{"title":"substring","type":"object","required":["begin"],"properties":{"begin":{"type":"integer","description":"The index of the first character to include in the returned substring.\n\n\nIf `begin` is set to -1, the transform will begin at character 0 of the input data\n","example":1,"format":"int32"},"beginOffset":{"type":"integer","description":"This integer value is the number of characters to add to the begin attribute when returning a substring. \n\nThis attribute is only used if begin is not -1.\n","example":3,"format":"int32"},"end":{"type":"integer","description":"The index of the first character to exclude from the returned substring.\n\nIf end is -1 or not provided at all, the substring transform will return everything up to the end of the input string.\n","example":6,"format":"int32"},"endOffset":{"type":"integer","description":"This integer value is the number of characters to add to the end attribute when returning a substring. \n\nThis attribute is only used if end is provided and is not -1.\n","example":1,"format":"int32"},"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"trim","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"upper","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false},"input":{"type":"object","description":"This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.","additionalProperties":true,"example":{"type":"accountAttribute","attributes":{"attributeName":"first_name","sourceName":"Source"}}}}},{"title":"uuid","type":"object","properties":{"requiresPeriodicRefresh":{"type":"boolean","description":"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process","example":false,"default":false}}}]},"internal":{"type":"boolean","readOnly":true,"description":"Indicates whether this is an internal SailPoint-created transform or a customer-created transform","example":false}}}}}},"400":{"description":"Client Error - Returned if the request body is invalid.","content":{"application/json":{"schema":{"type":"object","properties":{"detailCode":{"type":"string","description":"Fine-grained error code providing more detail of the error.","example":"400.1 Bad Request Content"},"trackingId":{"type":"string","description":"Unique tracking id for the error.","example":"e7eab60924f64aa284175b9fa3309599"},"messages":{"type":"array","description":"Generic localized reason for error","items":{"type":"object","properties":{"locale":{"type":"string","description":"The locale for the message text, a BCP 47 language tag.","example":"en-US"},"localeOrigin":{"type":"string","enum":["DEFAULT","REQUEST"],"description":"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.","example":"DEFAULT"},"text":{"type":"string","description":"Actual text of the error message in the indicated locale.","example":"The request was syntactically correct but its content is semantically invalid."}}}},"causes":{"type":"array","description":"Plain-text descriptive reasons to provide additional detail to the text provided in the messages field","items":{"type":"object","properties":{"locale":{"type":"string","description":"The locale for the message text, a BCP 47 language tag.","example":"en-US"},"localeOrigin":{"type":"string","enum":["DEFAULT","REQUEST"],"description":"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.","example":"DEFAULT"},"text":{"type":"string","description":"Actual text of the error message in the indicated locale.","example":"The request was syntactically correct but its content is semantically invalid."}}}}}}}}},"401":{"description":"Unauthorized - Returned if there is no authorization header, or if the JWT token is expired.","content":{"application/json":{"schema":{"type":"object","properties":{"error":{"description":"A message describing the error","example":"JWT validation failed: JWT is expired"}}}}}},"403":{"description":"Forbidden - Returned if the user you are running as, doesn't have access to this end-point.","content":{"application/json":{"schema":{"type":"object","properties":{"detailCode":{"type":"string","description":"Fine-grained error code providing more detail of the error.","example":"400.1 Bad Request Content"},"trackingId":{"type":"string","description":"Unique tracking id for the error.","example":"e7eab60924f64aa284175b9fa3309599"},"messages":{"type":"array","description":"Generic localized reason for error","items":{"type":"object","properties":{"locale":{"type":"string","description":"The locale for the message text, a BCP 47 language tag.","example":"en-US"},"localeOrigin":{"type":"string","enum":["DEFAULT","REQUEST"],"description":"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.","example":"DEFAULT"},"text":{"type":"string","description":"Actual text of the error message in the indicated locale.","example":"The request was syntactically correct but its content is semantically invalid."}}}},"causes":{"type":"array","description":"Plain-text descriptive reasons to provide additional detail to the text provided in the messages field","items":{"type":"object","properties":{"locale":{"type":"string","description":"The locale for the message text, a BCP 47 language tag.","example":"en-US"},"localeOrigin":{"type":"string","enum":["DEFAULT","REQUEST"],"description":"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.","example":"DEFAULT"},"text":{"type":"string","description":"Actual text of the error message in the indicated locale.","example":"The request was syntactically correct but its content is semantically invalid."}}}}}},"examples":{"403":{"summary":"An example of a 403 response object","value":{"detailCode":"403 Forbidden","trackingId":"b21b1f7ce4da4d639f2c62a57171b427","messages":[{"locale":"en-US","localeOrigin":"DEFAULT","text":"The server understood the request but refuses to authorize it."}]}}}}}},"404":{"description":"Not Found - returned if the request URL refers to a resource or object that does not exist","content":{"application/json":{"schema":{"type":"object","properties":{"detailCode":{"type":"string","description":"Fine-grained error code providing more detail of the error.","example":"400.1 Bad Request Content"},"trackingId":{"type":"string","description":"Unique tracking id for the error.","example":"e7eab60924f64aa284175b9fa3309599"},"messages":{"type":"array","description":"Generic localized reason for error","items":{"type":"object","properties":{"locale":{"type":"string","description":"The locale for the message text, a BCP 47 language tag.","example":"en-US"},"localeOrigin":{"type":"string","enum":["DEFAULT","REQUEST"],"description":"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.","example":"DEFAULT"},"text":{"type":"string","description":"Actual text of the error message in the indicated locale.","example":"The request was syntactically correct but its content is semantically invalid."}}}},"causes":{"type":"array","description":"Plain-text descriptive reasons to provide additional detail to the text provided in the messages field","items":{"type":"object","properties":{"locale":{"type":"string","description":"The locale for the message text, a BCP 47 language tag.","example":"en-US"},"localeOrigin":{"type":"string","enum":["DEFAULT","REQUEST"],"description":"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.","example":"DEFAULT"},"text":{"type":"string","description":"Actual text of the error message in the indicated locale.","example":"The request was syntactically correct but its content is semantically invalid."}}}}}},"examples":{"404":{"summary":"An example of a 404 response object","value":{"detailCode":"404 Not found","trackingId":"b21b1f7ce4da4d639f2c62a57171b427","messages":[{"locale":"en-US","localeOrigin":"DEFAULT","text":"The server did not find a current representation for the target resource."}]}}}}}},"429":{"description":"Too Many Requests - Returned in response to too many requests in a given period of time - rate limited. The Retry-After header in the response includes how long to wait before trying again.","content":{"application/json":{"schema":{"type":"object","properties":{"message":{"description":"A message describing the error","example":" Rate Limit Exceeded "}}}}}},"500":{"description":"Internal Server Error - Returned if there is an unexpected error.","content":{"application/json":{"schema":{"type":"object","properties":{"detailCode":{"type":"string","description":"Fine-grained error code providing more detail of the error.","example":"400.1 Bad Request Content"},"trackingId":{"type":"string","description":"Unique tracking id for the error.","example":"e7eab60924f64aa284175b9fa3309599"},"messages":{"type":"array","description":"Generic localized reason for error","items":{"type":"object","properties":{"locale":{"type":"string","description":"The locale for the message text, a BCP 47 language tag.","example":"en-US"},"localeOrigin":{"type":"string","enum":["DEFAULT","REQUEST"],"description":"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.","example":"DEFAULT"},"text":{"type":"string","description":"Actual text of the error message in the indicated locale.","example":"The request was syntactically correct but its content is semantically invalid."}}}},"causes":{"type":"array","description":"Plain-text descriptive reasons to provide additional detail to the text provided in the messages field","items":{"type":"object","properties":{"locale":{"type":"string","description":"The locale for the message text, a BCP 47 language tag.","example":"en-US"},"localeOrigin":{"type":"string","enum":["DEFAULT","REQUEST"],"description":"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice.","example":"DEFAULT"},"text":{"type":"string","description":"Actual text of the error message in the indicated locale.","example":"The request was syntactically correct but its content is semantically invalid."}}}}}},"examples":{"500":{"summary":"An example of a 500 response object","value":{"detailCode":"500.0 Internal Fault","trackingId":"b21b1f7ce4da4d639f2c62a57171b427","messages":[{"locale":"en-US","localeOrigin":"DEFAULT","text":"An internal fault occurred."}]}}}}}}},"security":[{"bearerAuth":["idn:transforms:write"]}],"method":"post","path":"/transforms","servers":[{"url":"https://{tenant}.api.identitynow.com/v3","description":"This is the production API server.","variables":{"tenant":{"default":"sailpoint","description":"This is the name of your tenant, typically your company's name."}}}],"securitySchemes":{"oauth2":{"type":"oauth2","description":"OAuth2 Bearer token (JWT). See [IdentityNow REST API Authentication](https://developer.sailpoint.com/docs/authentication.html) for more information.\n- Directions for generating a [personal access token](https://developer.sailpoint.com/docs/authentication.html#personal-access-tokens)\n- Directions using [client credentials flow](https://developer.sailpoint.com/docs/authentication.html#client-credentials-grant-flow)\n- Directions for using [authorization code flow](https://developer.sailpoint.com/docs/authentication.html#authorization-code-grant-flow)\n\nWhich authentication method should I choose?  See our [guide](https://developer.sailpoint.com/docs/authentication.html#which-oauth-2-0-grant-flow-should-i-use)\n\nLearn more about how to find your `tokenUrl` and `authorizationUrl` [in our docs](https://developer.sailpoint.com/docs/authentication.html#finding-your-tenant-s-oauth-details)\n","flows":{"clientCredentials":{"tokenUrl":"https://tenant.api.identitynow.com/oauth/token","scopes":{"sp:scopes:default":"default scope","sp:scopes:all":"access to all scopes"}},"authorizationCode":{"authorizationUrl":"https://tenant.identitynow.com/oauth/authorize","tokenUrl":"https://tenant.api.identitynow.com/oauth/token","scopes":{"sp:scopes:default":"default scope","sp:scopes:all":"access to all scopes"}}}}},"jsonRequestBodyExample":{"id":"2cd78adghjkja34jh2b1hkjhasuecd","name":"Timestamp To Date","type":"dateFormat","internal":false},"info":{"contact":{"email":"developers@sailpoint.com","name":"Developer Relations","url":"https://developer.sailpoint.com/discuss"},"description":"These are the public APIs for SailPoint's SaaS services. We encourage you to join the SailPoint Developer Community forum at https://developer.sailpoint.com/discuss to connect with other developers using our APIs.","title":"SailPoint - SaaS API","version":"3.0.0"},"postman":{"name":"Create transform","description":{"content":"Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.","type":"text/plain"},"url":{"path":["transforms"],"host":["{{baseUrl}}"],"query":[],"variable":[]},"header":[{"key":"Content-Type","value":"application/json"},{"key":"Accept","value":"application/json"}],"method":"POST","body":{"mode":"raw","raw":"\"\"","options":{"raw":{"language":"json"}}}}}
sidebar_class_name: "post api-method"
info_path: docs/idn/sailpoint-api-v3/sail-point-saa-s-api
---

import ApiTabs from "@theme/ApiTabs";
import MimeTabs from "@theme/MimeTabs";
import ParamsItem from "@theme/ParamsItem";
import ResponseSamples from "@theme/ResponseSamples";
import SchemaItem from "@theme/SchemaItem"
import SchemaTabs from "@theme/SchemaTabs";
import DiscriminatorTabs from "@theme/DiscriminatorTabs";
import TabItem from "@theme/TabItem";

## Create transform



Creates a new transform object immediately. By default, the internal flag is set to false to indicate that this is a custom transform. Only SailPoint employees have the ability to create a transform with internal set to true. Newly created Transforms can be used in the Identity Profile mappings within the UI. A token with transform write authority is required to call this API.

<MimeTabs><TabItem label={"application/json"} value={"application/json-schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Request Body</strong><strong style={{"fontSize":"var(--ifm-code-font-size)","color":"var(--openapi-required)"}}> required</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}><div style={{"marginTop":"1rem","marginBottom":"1rem"}}>

The transform to be created.

</div></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"name"} required={true} schemaDescription={"Unique name of this transform"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={true} schemaDescription={"The type of transform operation"} schemaName={"string"} qualifierMessage={"**Possible values:** [`accountAttribute`, `base64Decode`, `base64Encode`, `concat`, `conditional`, `dateCompare`, `dateFormat`, `dateMath`, `decomposeDiacriticalMarks`, `e164phone`, `firstValid`, `rule`, `identityAttribute`, `indexOf`, `iso3166`, `lastIndexOf`, `leftPad`, `lookup`, `lower`, `normalizeNames`, `randomAlphaNumeric`, `randomNumeric`, `reference`, `replaceAll`, `replace`, `rightPad`, `split`, `static`, `substring`, `trim`, `upper`, `usernameGenerator`, `uuid`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>attributes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Meta-data about the transform. Values in this list are specific to the type of transform to be executed.

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"accountAttribute"} value={"0-item-properties"}><SchemaItem collapsible={false} name={"sourceName"} required={true} schemaDescription={"A reference to the source to search for the account"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"attributeName"} required={true} schemaDescription={"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortAttribute"} required={false} schemaDescription={"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortDescending"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountReturnFirstLink"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountFilter"} required={false} schemaDescription={"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountPropertyFilter"} required={false} schemaDescription={"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"base64Decode"} value={"1-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"base64Encode"} value={"2-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"concat"} value={"3-item-properties"}><SchemaItem collapsible={false} name={"values"} required={true} schemaDescription={"An array of items to join together"} schemaName={"object[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"conditional"} value={"4-item-properties"}><SchemaItem collapsible={false} name={"expression"} required={true} schemaDescription={"A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms. \n\nThe `eq` operator is the only valid comparison"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"positiveCondition"} required={true} schemaDescription={"The output of the transform if the expression evalutes to true"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"negativeCondition"} required={true} schemaDescription={"The output of the transform if the expression evalutes to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateCompare"} value={"5-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>firstDate</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is the first date to consider (The date that would be on the left hand side of the comparison operation).

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"accountAttribute"} value={"0-item-properties"}><SchemaItem collapsible={false} name={"sourceName"} required={true} schemaDescription={"A reference to the source to search for the account"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"attributeName"} required={true} schemaDescription={"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortAttribute"} required={false} schemaDescription={"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortDescending"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountReturnFirstLink"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountFilter"} required={false} schemaDescription={"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountPropertyFilter"} required={false} schemaDescription={"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateFormat"} value={"1-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>inputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>outputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>secondDate</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is the second date to consider (The date that would be on the right hand side of the comparison operation).

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"accountAttribute"} value={"0-item-properties"}><SchemaItem collapsible={false} name={"sourceName"} required={true} schemaDescription={"A reference to the source to search for the account"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"attributeName"} required={true} schemaDescription={"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortAttribute"} required={false} schemaDescription={"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortDescending"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountReturnFirstLink"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountFilter"} required={false} schemaDescription={"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountPropertyFilter"} required={false} schemaDescription={"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateFormat"} value={"1-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>inputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>outputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"operator"} required={true} schemaDescription={"This is the comparison to perform.\n| Operation | Description |\n| --------- | ------- |\n| LT        | Strictly less than: firstDate < secondDate |\n| LTE       | Less than or equal to: firstDate <= secondDate |\n| GT        | Strictly greater than: firstDate > secondDate |\n| GTE       | Greater than or equal to: firstDate >= secondDate |\n"} schemaName={"string"} qualifierMessage={"**Possible values:** [`LT`, `LTE`, `GT`, `GTE`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"positiveCondition"} required={true} schemaDescription={"The output of the transform if the expression evalutes to true"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"negativeCondition"} required={true} schemaDescription={"The output of the transform if the expression evalutes to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateFormat"} value={"6-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>inputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>outputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateMath"} value={"7-item-properties"}><SchemaItem collapsible={false} name={"expression"} required={true} schemaDescription={"A string value of the date and time components to operation on, along with the math operations to execute.\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"roundUp"} required={false} schemaDescription={"A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression. \n\n\nIf not provided, the transform will default to `false`\n\n\n`true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)\n\n\n`false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated)\n"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"decomposeDiacriticalMarks"} value={"8-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"e164phone"} value={"9-item-properties"}><SchemaItem collapsible={false} name={"defaultRegion"} required={false} schemaDescription={"This is an optional attribute that can be used to define the region of the phone number to format into.\n\n\nIf defaultRegion is not provided, it will take US as the default country.\n\n\nThe format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"firstValid"} value={"10-item-properties"}><SchemaItem collapsible={false} name={"values"} required={true} schemaDescription={"An array of attributes to evaluate for existence."} schemaName={"object[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"ignoreErrors"} required={false} schemaDescription={"a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur."} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem></TabItem><TabItem label={"identityAttribute"} value={"12-item-properties"}><SchemaItem collapsible={false} name={"name"} required={true} schemaDescription={"The system (camel-cased) name of the identity attribute to bring in"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"indexOf"} value={"13-item-properties"}><SchemaItem collapsible={false} name={"substring"} required={true} schemaDescription={"A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"iso3166"} value={"14-item-properties"}><SchemaItem collapsible={false} name={"format"} required={false} schemaDescription={"An optional value to denote which ISO 3166 format to return. Valid values are:\n\n\n`alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied\n\n\n`alpha3` - Three-character country code (e.g., \"USA\")\n\n\n`numeric` - The numeric country code (e.g., \"840\")\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"leftPad"} value={"15-item-properties"}><SchemaItem collapsible={false} name={"length"} required={true} schemaDescription={"An integer value for the desired length of the final output string"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"padding"} required={false} schemaDescription={"A string value representing the character that the incoming data should be padded with to get to the desired length\n\n\nIf not provided, the transform will default to a single space (\" \") character for padding\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"lookup"} value={"16-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>table</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched


>**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return "Unknown Region" for the attribute that is mapped to this transform.


</div></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"lower"} value={"17-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"nameNormalizer"} value={"18-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"randomAlphaNumeric"} value={"19-item-properties"}><SchemaItem collapsible={false} name={"length"} required={false} schemaDescription={"This is an integer value specifying the size/number of characters the random string must contain\n\n\n* This value must be a positive number and cannot be blank\n\n\n* If no length is provided, the transform will default to a value of `32`\n\n\n* Due to identity attribute data constraints, the maximum allowable value is `450` characters\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"randomNumeric"} value={"20-item-properties"}><SchemaItem collapsible={false} name={"length"} required={false} schemaDescription={"This is an integer value specifying the size/number of characters the random string must contain\n\n\n* This value must be a positive number and cannot be blank\n\n\n* If no length is provided, the transform will default to a value of `32`\n\n\n* Due to identity attribute data constraints, the maximum allowable value is `450` characters\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"reference"} value={"21-item-properties"}><SchemaItem collapsible={false} name={"id"} required={true} schemaDescription={"This ID specifies the name of the pre-existing transform which you want to use within your current transform"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"replaceAll"} value={"22-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>table</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.

</div></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"replace"} value={"23-item-properties"}><SchemaItem collapsible={false} name={"regex"} required={true} schemaDescription={"This can be a string or a regex pattern in which you want to replace."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"replacement"} required={true} schemaDescription={"This is the replacement string that should be substituded wherever the string or pattern is found."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"rightPad"} value={"24-item-properties"}><SchemaItem collapsible={false} name={"length"} required={true} schemaDescription={"An integer value for the desired length of the final output string"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"padding"} required={false} schemaDescription={"A string value representing the character that the incoming data should be padded with to get to the desired length\n\n\nIf not provided, the transform will default to a single space (\" \") character for padding\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"split"} value={"25-item-properties"}><SchemaItem collapsible={false} name={"delimiter"} required={true} schemaDescription={"This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"index"} required={true} schemaDescription={"An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"throws"} required={false} schemaDescription={"A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)\n\n\n`true` - The transform should return \"IndexOutOfBoundsException\"\n\n\n`false` - The transform should return null\n\n\nIf not provided, the transform will default to false and return a null\n"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"static"} value={"26-item-properties"}><SchemaItem collapsible={false} name={"values"} required={true} schemaDescription={"This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem></TabItem><TabItem label={"substring"} value={"27-item-properties"}><SchemaItem collapsible={false} name={"begin"} required={true} schemaDescription={"The index of the first character to include in the returned substring.\n\n\nIf `begin` is set to -1, the transform will begin at character 0 of the input data\n"} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"beginOffset"} required={false} schemaDescription={"This integer value is the number of characters to add to the begin attribute when returning a substring. \n\nThis attribute is only used if begin is not -1.\n"} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"end"} required={false} schemaDescription={"The index of the first character to exclude from the returned substring.\n\nIf end is -1 or not provided at all, the substring transform will return everything up to the end of the input string.\n"} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"endOffset"} required={false} schemaDescription={"This integer value is the number of characters to add to the end attribute when returning a substring. \n\nThis attribute is only used if end is provided and is not -1.\n"} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"trim"} value={"28-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"upper"} value={"29-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"uuid"} value={"30-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem></TabItem></SchemaTabs></div></li></div></details></SchemaItem></ul></details></TabItem></MimeTabs><div><ApiTabs><TabItem label={"201"} value={"201"}><div>

Indicates the transform was successfully created and returns its representation.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"id"} required={false} schemaDescription={"Unique ID of this transform"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={"Unique name of this transform"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"type"} required={false} schemaDescription={"The type of transform operation"} schemaName={"string"} qualifierMessage={"**Possible values:** [`accountAttribute`, `base64Decode`, `base64Encode`, `concat`, `conditional`, `dateCompare`, `dateFormat`, `dateMath`, `decomposeDiacriticalMarks`, `e164phone`, `firstValid`, `rule`, `identityAttribute`, `indexOf`, `iso3166`, `lastIndexOf`, `leftPad`, `lookup`, `lower`, `normalizeNames`, `randomAlphaNumeric`, `randomNumeric`, `reference`, `replaceAll`, `replace`, `rightPad`, `split`, `static`, `substring`, `trim`, `upper`, `usernameGenerator`, `uuid`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>attributes</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Meta-data about the transform. Values in this list are specific to the type of transform to be executed.

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"accountAttribute"} value={"0-item-properties"}><SchemaItem collapsible={false} name={"sourceName"} required={false} schemaDescription={"A reference to the source to search for the account"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"attributeName"} required={false} schemaDescription={"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortAttribute"} required={false} schemaDescription={"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortDescending"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountReturnFirstLink"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountFilter"} required={false} schemaDescription={"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountPropertyFilter"} required={false} schemaDescription={"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"base64Decode"} value={"1-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"base64Encode"} value={"2-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"concat"} value={"3-item-properties"}><SchemaItem collapsible={false} name={"values"} required={false} schemaDescription={"An array of items to join together"} schemaName={"object[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"conditional"} value={"4-item-properties"}><SchemaItem collapsible={false} name={"expression"} required={false} schemaDescription={"A comparison statement that follows the structure of `ValueA eq ValueB` where `ValueA` and `ValueB` are static strings or outputs of other transforms. \n\nThe `eq` operator is the only valid comparison"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"positiveCondition"} required={false} schemaDescription={"The output of the transform if the expression evalutes to true"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"negativeCondition"} required={false} schemaDescription={"The output of the transform if the expression evalutes to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateCompare"} value={"5-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>firstDate</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is the first date to consider (The date that would be on the left hand side of the comparison operation).

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"accountAttribute"} value={"0-item-properties"}><SchemaItem collapsible={false} name={"sourceName"} required={false} schemaDescription={"A reference to the source to search for the account"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"attributeName"} required={false} schemaDescription={"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortAttribute"} required={false} schemaDescription={"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortDescending"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountReturnFirstLink"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountFilter"} required={false} schemaDescription={"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountPropertyFilter"} required={false} schemaDescription={"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateFormat"} value={"1-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>inputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>outputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>secondDate</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is the second date to consider (The date that would be on the right hand side of the comparison operation).

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"accountAttribute"} value={"0-item-properties"}><SchemaItem collapsible={false} name={"sourceName"} required={false} schemaDescription={"A reference to the source to search for the account"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"attributeName"} required={false} schemaDescription={"The name of the attribute on the account to return. This should match the name of the account attribute name visible in the user interface, or on the source schema."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortAttribute"} required={false} schemaDescription={"The value of this configuration is a string name of the attribute to use when determining the ordering of returned accounts when there are multiple entries"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountSortDescending"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls the order of the sort when there are multiple accounts. If not defined, the transform will default to false (ascending order)"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountReturnFirstLink"} required={false} schemaDescription={"The value of this configuration is a boolean (true/false). Controls which account to source a value from for an attribute.  If this flag is set to true, the transform returns the value from the first account in the list, even if it is null. If it is set to false, the transform returns the first non-null value. If not defined, the transform will default to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountFilter"} required={false} schemaDescription={"This expression queries the database to narrow search results. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the database.  The default filter will always include the source and identity, and any subsequent expressions will be combined in an AND operation to the existing search criteria.\n\nOnly certain searchable attributes are available: </br> - `nativeIdentity` - the Account ID </br> - `displayName` - the Account Name </br> - `entitlements` - a boolean value to determine if the account has entitlements"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"accountPropertyFilter"} required={false} schemaDescription={"This expression is used to search and filter accounts in memory. The value of this configuration is a sailpoint.object.Filter expression and used when searching against the returned resultset.\n\nAll account attributes are available for filtering as this operation is performed in memory."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateFormat"} value={"1-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>inputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>outputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"operator"} required={false} schemaDescription={"This is the comparison to perform.\n| Operation | Description |\n| --------- | ------- |\n| LT        | Strictly less than: firstDate < secondDate |\n| LTE       | Less than or equal to: firstDate <= secondDate |\n| GT        | Strictly greater than: firstDate > secondDate |\n| GTE       | Greater than or equal to: firstDate >= secondDate |\n"} schemaName={"string"} qualifierMessage={"**Possible values:** [`LT`, `LTE`, `GT`, `GTE`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"positiveCondition"} required={false} schemaDescription={"The output of the transform if the expression evalutes to true"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"negativeCondition"} required={false} schemaDescription={"The output of the transform if the expression evalutes to false"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateFormat"} value={"6-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>inputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data is coming in as.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>outputFormat</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

A string value indicating either the explicit SimpleDateFormat or the built-in named format that the data should be formatted into.

*If no inputFormat is provided, the transform assumes that it is in ISO8601 format*

</div><li><div><span className={"badge badge--info"}>oneOf</span><SchemaTabs><TabItem label={"Named Construct"} value={"0-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

**Possible values:** [`ISO8601`, `LDAP`, `PEOPLE_SOFT`, `EPOCH_TIME_JAVA`, `EPOCH_TIME_WIN32`]

</div><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

| Construct       | Date Time Pattern | Description |
| ---------       | ----------------- | ----------- |
| ISO8601         | `yyyy-MM-dd'T'HH:mm:ss.SSSX` | The ISO8601 standard. |          
| LDAP            | `yyyyMMddHHmmss.Z`           | The LDAP standard.    |
| PEOPLE_SOFT     | `MM/dd/yyyy`                 | The date format People Soft uses. |
| EPOCH_TIME_JAVA | # ms from midnight, January 1st, 1970 | The incoming date value as elapsed time in milliseconds from midnight, January 1st, 1970. |
| EPOCH_TIME_WIN32| # intervals of 100ns from midnight, January 1st, 1601 | The incoming date value as elapsed time in 100-nanosecond intervals from midnight, January 1st, 1601. |


</div></div></li></TabItem><TabItem label={"Java Simple Date Format"} value={"1-item-properties"}><li><div><strong>string</strong><div style={{"marginTop":"var(--ifm-table-cell-padding)"}}>

There are a variety of date time patterns you can express using SimpleDateFormat. The following table lists examples of different date time patterns expressed in the SimpleDateFormat and how they display. Refer to the SimpleDateFormat syntax page for more information.

>NOTE: The following examples show how date and time patterns are interpreted in the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.
  (This table is from the SimpleDateFormat page.)

| Date Time Pattern | Result |
| ----------------- | ------ |
| `yyyy.MM.dd G 'at' HH:mm:ss z` | `2001.07.04 AD at 12:08:56 PDT` |
| `EEE, MMM d, ''yy` | Wed, Jul 4, '01 |
| `h:mm a`           | 12:08 PM |
| `hh 'o''clock' a, zzzz` | 12 o'clock PM, Pacific Daylight Time |
| `K:mm a, z`             | 0:08 PM, PDT |
| `yyyyy.MMMMM.dd GGG hh:mm aaa` | 02001.July.04 AD 12:08 PM |
| `EEE, d MMM yyyy HH:mm:ss Z`  | Wed, 4 Jul 2001 12:08:56 -0700 |
| `yyMMddHHmmssZ`               | 010704120856-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSZ`  | 2001-07-04T12:08:56.235-0700 |
| `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` | 2001-07-04T12:08:56.235-07:00 |
| `YYYY-'W'ww-u`                 | 2001-W27-3 |


</div></div></li></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"dateMath"} value={"7-item-properties"}><SchemaItem collapsible={false} name={"expression"} required={false} schemaDescription={"A string value of the date and time components to operation on, along with the math operations to execute.\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"roundUp"} required={false} schemaDescription={"A boolean value to indicate whether the transform should round up or down when a rounding `/` operation is defined in the expression. \n\n\nIf not provided, the transform will default to `false`\n\n\n`true` indicates the transform should round up (i.e., truncate the fractional date/time component indicated and then add one unit of that component)\n\n\n`false` indicates the transform should round down (i.e., truncate the fractional date/time component indicated)\n"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"decomposeDiacriticalMarks"} value={"8-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"e164phone"} value={"9-item-properties"}><SchemaItem collapsible={false} name={"defaultRegion"} required={false} schemaDescription={"This is an optional attribute that can be used to define the region of the phone number to format into.\n\n\nIf defaultRegion is not provided, it will take US as the default country.\n\n\nThe format of the country code should be in [ISO 3166-1 alpha-2 format](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"firstValid"} value={"10-item-properties"}><SchemaItem collapsible={false} name={"values"} required={false} schemaDescription={"An array of attributes to evaluate for existence."} schemaName={"object[]"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"ignoreErrors"} required={false} schemaDescription={"a true or false value representing to move on to the next option if an error (like an Null Pointer Exception) were to occur."} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem></TabItem><TabItem label={"identityAttribute"} value={"12-item-properties"}><SchemaItem collapsible={false} name={"name"} required={false} schemaDescription={"The system (camel-cased) name of the identity attribute to bring in"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"indexOf"} value={"13-item-properties"}><SchemaItem collapsible={false} name={"substring"} required={false} schemaDescription={"A substring to search for, searches the entire calling string, and returns the index of the first occurrence of the specified substring."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"iso3166"} value={"14-item-properties"}><SchemaItem collapsible={false} name={"format"} required={false} schemaDescription={"An optional value to denote which ISO 3166 format to return. Valid values are:\n\n\n`alpha2` - Two-character country code (e.g., \"US\"); this is the default value if no format is supplied\n\n\n`alpha3` - Three-character country code (e.g., \"USA\")\n\n\n`numeric` - The numeric country code (e.g., \"840\")\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"leftPad"} value={"15-item-properties"}><SchemaItem collapsible={false} name={"length"} required={false} schemaDescription={"An integer value for the desired length of the final output string"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"padding"} required={false} schemaDescription={"A string value representing the character that the incoming data should be padded with to get to the desired length\n\n\nIf not provided, the transform will default to a single space (\" \") character for padding\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"lookup"} value={"16-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>table</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is a JSON object of key-value pairs. The key is the string that will attempt to be matched to the input, and the value is the output string that should be returned if the key is matched


>**Note** the use of the optional default key value here; if none of the three countries in the above example match the input string, the transform will return "Unknown Region" for the attribute that is mapped to this transform.


</div></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"lower"} value={"17-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"nameNormalizer"} value={"18-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"randomAlphaNumeric"} value={"19-item-properties"}><SchemaItem collapsible={false} name={"length"} required={false} schemaDescription={"This is an integer value specifying the size/number of characters the random string must contain\n\n\n* This value must be a positive number and cannot be blank\n\n\n* If no length is provided, the transform will default to a value of `32`\n\n\n* Due to identity attribute data constraints, the maximum allowable value is `450` characters\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"randomNumeric"} value={"20-item-properties"}><SchemaItem collapsible={false} name={"length"} required={false} schemaDescription={"This is an integer value specifying the size/number of characters the random string must contain\n\n\n* This value must be a positive number and cannot be blank\n\n\n* If no length is provided, the transform will default to a value of `32`\n\n\n* Due to identity attribute data constraints, the maximum allowable value is `450` characters\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"reference"} value={"21-item-properties"}><SchemaItem collapsible={false} name={"id"} required={false} schemaDescription={"This ID specifies the name of the pre-existing transform which you want to use within your current transform"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"replaceAll"} value={"22-item-properties"}><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>table</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

An attribute of key-value pairs. Each pair identifies the pattern to search for as its key, and the replacement string as its value.

</div></div></details></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"replace"} value={"23-item-properties"}><SchemaItem collapsible={false} name={"regex"} required={false} schemaDescription={"This can be a string or a regex pattern in which you want to replace."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"replacement"} required={false} schemaDescription={"This is the replacement string that should be substituded wherever the string or pattern is found."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"rightPad"} value={"24-item-properties"}><SchemaItem collapsible={false} name={"length"} required={false} schemaDescription={"An integer value for the desired length of the final output string"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"padding"} required={false} schemaDescription={"A string value representing the character that the incoming data should be padded with to get to the desired length\n\n\nIf not provided, the transform will default to a single space (\" \") character for padding\n"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"split"} value={"25-item-properties"}><SchemaItem collapsible={false} name={"delimiter"} required={false} schemaDescription={"This can be either a single character or a regex expression, and is used by the transform to identify the break point between two substrings in the incoming data"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"index"} required={false} schemaDescription={"An integer value for the desired array element after the incoming data has been split into a list; the array is a 0-based object, so the first array element would be index 0, the second element would be index 1, etc."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"throws"} required={false} schemaDescription={"A boolean (true/false) value which indicates whether an exception should be thrown and returned as an output when an index is out of bounds with the resultant array (i.e., the provided index value is larger than the size of the array)\n\n\n`true` - The transform should return \"IndexOutOfBoundsException\"\n\n\n`false` - The transform should return null\n\n\nIf not provided, the transform will default to false and return a null\n"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"static"} value={"26-item-properties"}><SchemaItem collapsible={false} name={"values"} required={false} schemaDescription={"This must evaluate to a JSON string, either through a fixed value or through conditional logic using the Apache Velocity Template Language."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem></TabItem><TabItem label={"substring"} value={"27-item-properties"}><SchemaItem collapsible={false} name={"begin"} required={false} schemaDescription={"The index of the first character to include in the returned substring.\n\n\nIf `begin` is set to -1, the transform will begin at character 0 of the input data\n"} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"beginOffset"} required={false} schemaDescription={"This integer value is the number of characters to add to the begin attribute when returning a substring. \n\nThis attribute is only used if begin is not -1.\n"} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"end"} required={false} schemaDescription={"The index of the first character to exclude from the returned substring.\n\nIf end is -1 or not provided at all, the substring transform will return everything up to the end of the input string.\n"} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"endOffset"} required={false} schemaDescription={"This integer value is the number of characters to add to the end attribute when returning a substring. \n\nThis attribute is only used if end is provided and is not -1.\n"} schemaName={"int32"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"trim"} value={"28-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"upper"} value={"29-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>input</strong><span style={{"opacity":"0.6"}}> object</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

This is an optional attribute that can explicitly define the input data which will be fed into the transform logic. If input is not provided, the transform will take its input from the source and attribute combination configured via the UI.

</div></div></details></SchemaItem></TabItem><TabItem label={"uuid"} value={"30-item-properties"}><SchemaItem collapsible={false} name={"requiresPeriodicRefresh"} required={false} schemaDescription={"A value that indicates whether the transform logic should be re-evaluated every evening as part of the identity refresh process"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={false}></SchemaItem></TabItem></SchemaTabs></div></li></div></details></SchemaItem><SchemaItem collapsible={false} name={"internal"} required={false} schemaDescription={"Indicates whether this is an internal SailPoint-created transform or a customer-created transform"} schemaName={"boolean"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></ul></details></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"400"} value={"400"}><div>

Client Error - Returned if the request body is invalid.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"detailCode"} required={false} schemaDescription={"Fine-grained error code providing more detail of the error."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"trackingId"} required={false} schemaDescription={"Unique tracking id for the error."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>messages</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Generic localized reason for error

</div><SchemaItem collapsible={false} name={"locale"} required={false} schemaDescription={"The locale for the message text, a BCP 47 language tag."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"localeOrigin"} required={false} schemaDescription={"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice."} schemaName={"string"} qualifierMessage={"**Possible values:** [`DEFAULT`, `REQUEST`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"text"} required={false} schemaDescription={"Actual text of the error message in the indicated locale."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>causes</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Plain-text descriptive reasons to provide additional detail to the text provided in the messages field

</div><SchemaItem collapsible={false} name={"locale"} required={false} schemaDescription={"The locale for the message text, a BCP 47 language tag."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"localeOrigin"} required={false} schemaDescription={"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice."} schemaName={"string"} qualifierMessage={"**Possible values:** [`DEFAULT`, `REQUEST`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"text"} required={false} schemaDescription={"Actual text of the error message in the indicated locale."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></ul></details></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"401"} value={"401"}><div>

Unauthorized - Returned if there is no authorization header, or if the JWT token is expired.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"error"} required={false} schemaDescription={"A message describing the error"} schemaName={""} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></ul></details></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"403"} value={"403"}><div>

Forbidden - Returned if the user you are running as, doesn't have access to this end-point.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"detailCode"} required={false} schemaDescription={"Fine-grained error code providing more detail of the error."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"trackingId"} required={false} schemaDescription={"Unique tracking id for the error."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>messages</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Generic localized reason for error

</div><SchemaItem collapsible={false} name={"locale"} required={false} schemaDescription={"The locale for the message text, a BCP 47 language tag."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"localeOrigin"} required={false} schemaDescription={"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice."} schemaName={"string"} qualifierMessage={"**Possible values:** [`DEFAULT`, `REQUEST`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"text"} required={false} schemaDescription={"Actual text of the error message in the indicated locale."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>causes</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Plain-text descriptive reasons to provide additional detail to the text provided in the messages field

</div><SchemaItem collapsible={false} name={"locale"} required={false} schemaDescription={"The locale for the message text, a BCP 47 language tag."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"localeOrigin"} required={false} schemaDescription={"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice."} schemaName={"string"} qualifierMessage={"**Possible values:** [`DEFAULT`, `REQUEST`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"text"} required={false} schemaDescription={"Actual text of the error message in the indicated locale."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></ul></details></TabItem><TabItem label={"403"} value={"403"}><ResponseSamples responseExample={"{\n  \"detailCode\": \"403 Forbidden\",\n  \"trackingId\": \"b21b1f7ce4da4d639f2c62a57171b427\",\n  \"messages\": [\n    {\n      \"locale\": \"en-US\",\n      \"localeOrigin\": \"DEFAULT\",\n      \"text\": \"The server understood the request but refuses to authorize it.\"\n    }\n  ]\n}"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"404"} value={"404"}><div>

Not Found - returned if the request URL refers to a resource or object that does not exist

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"detailCode"} required={false} schemaDescription={"Fine-grained error code providing more detail of the error."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"trackingId"} required={false} schemaDescription={"Unique tracking id for the error."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>messages</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Generic localized reason for error

</div><SchemaItem collapsible={false} name={"locale"} required={false} schemaDescription={"The locale for the message text, a BCP 47 language tag."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"localeOrigin"} required={false} schemaDescription={"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice."} schemaName={"string"} qualifierMessage={"**Possible values:** [`DEFAULT`, `REQUEST`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"text"} required={false} schemaDescription={"Actual text of the error message in the indicated locale."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>causes</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Plain-text descriptive reasons to provide additional detail to the text provided in the messages field

</div><SchemaItem collapsible={false} name={"locale"} required={false} schemaDescription={"The locale for the message text, a BCP 47 language tag."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"localeOrigin"} required={false} schemaDescription={"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice."} schemaName={"string"} qualifierMessage={"**Possible values:** [`DEFAULT`, `REQUEST`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"text"} required={false} schemaDescription={"Actual text of the error message in the indicated locale."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></ul></details></TabItem><TabItem label={"404"} value={"404"}><ResponseSamples responseExample={"{\n  \"detailCode\": \"404 Not found\",\n  \"trackingId\": \"b21b1f7ce4da4d639f2c62a57171b427\",\n  \"messages\": [\n    {\n      \"locale\": \"en-US\",\n      \"localeOrigin\": \"DEFAULT\",\n      \"text\": \"The server did not find a current representation for the target resource.\"\n    }\n  ]\n}"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"429"} value={"429"}><div>

Too Many Requests - Returned in response to too many requests in a given period of time - rate limited. The Retry-After header in the response includes how long to wait before trying again.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"message"} required={false} schemaDescription={"A message describing the error"} schemaName={""} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></ul></details></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"500"} value={"500"}><div>

Internal Server Error - Returned if there is an unexpected error.

</div><div><MimeTabs groupId={"mime-type"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs groupId={"schema-tabs"}><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"detailCode"} required={false} schemaDescription={"Fine-grained error code providing more detail of the error."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"trackingId"} required={false} schemaDescription={"Unique tracking id for the error."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>messages</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Generic localized reason for error

</div><SchemaItem collapsible={false} name={"locale"} required={false} schemaDescription={"The locale for the message text, a BCP 47 language tag."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"localeOrigin"} required={false} schemaDescription={"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice."} schemaName={"string"} qualifierMessage={"**Possible values:** [`DEFAULT`, `REQUEST`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"text"} required={false} schemaDescription={"Actual text of the error message in the indicated locale."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem><SchemaItem collapsible={true} className={"schemaItem"}><details style={{}}><summary style={{}}><strong>causes</strong><span style={{"opacity":"0.6"}}> object[]</span></summary><div style={{"marginLeft":"1rem"}}><div style={{"marginTop":".5rem","marginBottom":".5rem"}}>

Plain-text descriptive reasons to provide additional detail to the text provided in the messages field

</div><SchemaItem collapsible={false} name={"locale"} required={false} schemaDescription={"The locale for the message text, a BCP 47 language tag."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"localeOrigin"} required={false} schemaDescription={"An indicator of how the locale was selected. *DEFAULT* means the locale is the system default. *REQUEST* means the locale was selected from the request context (i.e., best match based on the *Accept-Language* header). Additional values may be added in the future without notice."} schemaName={"string"} qualifierMessage={"**Possible values:** [`DEFAULT`, `REQUEST`]"} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"text"} required={false} schemaDescription={"Actual text of the error message in the indicated locale."} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></div></details></SchemaItem></ul></details></TabItem><TabItem label={"500"} value={"500"}><ResponseSamples responseExample={"{\n  \"detailCode\": \"500.0 Internal Fault\",\n  \"trackingId\": \"b21b1f7ce4da4d639f2c62a57171b427\",\n  \"messages\": [\n    {\n      \"locale\": \"en-US\",\n      \"localeOrigin\": \"DEFAULT\",\n      \"text\": \"An internal fault occurred.\"\n    }\n  ]\n}"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem></ApiTabs></div>
      